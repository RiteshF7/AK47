This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-16T09:02:30.365Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
DeviceDetailsUtil.kt
IMEIHelper.kt
IMEIValidator.kt
NewDeviceCreator.kt
PermissionHelper.kt
SharedPrefUtils.kt

================================================================
Repository Files
================================================================

================
File: DeviceDetailsUtil.kt
================
import android.Manifest
import android.annotation.SuppressLint
import android.app.Activity
import android.app.admin.DevicePolicyManager
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.provider.Settings
import android.telephony.TelephonyManager
import android.util.Log
import android.widget.Toast
import androidx.core.content.ContextCompat
import com.google.firebase.messaging.FirebaseMessaging
import com.trex.rexandroidsecureclient.MyApplication
import com.trex.rexandroidsecureclient.utils.ClientSharedPrefs
import com.trex.rexandroidsecureclient.utils.PermissionHelper

class DeviceDetailsUtil {
    private val TAG: String = "DeviceInfoUtil"
    private val context = MyApplication.getAppContext()

    fun getDeviceModel(): String = Build.MODEL.ifBlank { "Unknown" }

    fun getDeviceName(): String =
        Settings.Global.getString(context.contentResolver, Settings.Global.DEVICE_NAME) ?: "Unknown"

    fun getAndroidVersion(): String = Build.VERSION.RELEASE.ifBlank { "Unknown" }

    fun getApiLevel(): Int = Build.VERSION.SDK_INT

    @SuppressLint("HardwareIds")
    fun getDeviceId(): String =
        Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
            ?: "Unknown"

    fun requestAndSaveImei(context: Activity) {
        var imei = ""
        PermissionHelper(context).checkAndRequestPermission(
            context,
            Manifest.permission.READ_PHONE_STATE,
            "This permission is required to get IMEI number",
        ) {
            if (it) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    val telephonyManager =
                        context.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager
                    imei = telephonyManager.imei ?: ClientSharedPrefs.IMEI_NOT_FOUND
                    ClientSharedPrefs().saveImei(imei)
                } else {
                    Log.e("IMEI ERROR: ", "getIMEI: Imei not available android < O")
                }
            }
        }
    }

    fun saveImei() {
        if (
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.READ_PHONE_STATE,
            ) == PackageManager.PERMISSION_GRANTED
        ) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                try {
                    val telephonyManager =
                        context.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager
                    val imei = telephonyManager.imei ?: ClientSharedPrefs.IMEI_NOT_FOUND
                    ClientSharedPrefs().saveImei(imei)
                } catch (e: Exception) {
                }
            }
        } else {
            Toast.makeText(context, "Imei permission not granted!", Toast.LENGTH_SHORT).show()
        }
    }

    fun getManufacturer(): String = Build.MANUFACTURER.ifBlank { "Unknown" }

    fun getBrand(): String = Build.BRAND.ifBlank { "Unknown" }

    fun getProduct(): String = Build.PRODUCT.ifBlank { "Unknown" }

    fun isOwnerApp(): Boolean {
        val manager =
            context.getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager
        return manager.isDeviceOwnerApp(context.packageName)
    }

    private fun saveFcmToken() {
        FirebaseMessaging.getInstance().token.addOnCompleteListener { task ->
            if (!task.isSuccessful) {
                Log.w(TAG, "Fetching FCM registration token failed", task.exception)
                return@addOnCompleteListener
            }

            // Get new FCM registration token
            val token = task.result

            // Log the token
            Log.d(TAG, "FCM Token: $token")

            // Here you can add code to save the token
            // For example, you might want to send it to your server
            // or save it in SharedPreferences
        }
    }

    fun getAllDeviceInfo(): Map<String, String> =
        mapOf(
            "Device Model" to getDeviceModel(),
            "Device Name" to getDeviceName(),
            "Android Version" to getAndroidVersion(),
            "API Level" to getApiLevel().toString(),
            "Device ID" to getDeviceId(),
            "Manufacturer" to getManufacturer(),
            "Brand" to getBrand(),
            "Product" to getProduct(),
        )
}

================
File: IMEIHelper.kt
================
import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.telephony.TelephonyManager
import androidx.core.app.ActivityCompat

class IMEIHelper(
    private val context: Activity,
) {
    companion object {
        const val PERMISSION_REQUEST_CODE = 100
    }

    // Check if permission is granted
    fun isPermissionGranted(): Boolean =
        ActivityCompat.checkSelfPermission(
            context,
            Manifest.permission.READ_PHONE_STATE,
        ) == PackageManager.PERMISSION_GRANTED

    // Request permission
    fun requestIMEIPermission() {
        if (!isPermissionGranted()) {
            ActivityCompat.requestPermissions(
                context,
                arrayOf(Manifest.permission.READ_PHONE_STATE),
                PERMISSION_REQUEST_CODE,
            )
        }
    }

    fun getIMEINumber(): String? {
        if (isPermissionGranted()) {
            val telephonyManager =
                context.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager
            return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                telephonyManager.imei
            } else {
                telephonyManager.deviceId
            }
        }
        return null
    }
}

================
File: IMEIValidator.kt
================
package com.trex.rexandroidsecureclient.utils

object IMEIValidator {
    /**
     * Validates an IMEI number.
     *
     * @param imei The IMEI number to validate.
     * @return true if the IMEI is valid, false otherwise.
     */
    fun isValidIMEI(imei: String): Boolean {
        //TODO remove in production
        return true
        // Remove any spaces or hyphens
        val cleanIMEI = imei.replace(Regex("\\s|-"), "")

        // Check if the IMEI is 15 or 17 digits long (17 includes check digit and a spare)
        if (cleanIMEI.length != 15 && cleanIMEI.length != 17) {
            return false
        }

        // Check if all characters are digits
        if (!cleanIMEI.all { it.isDigit() }) {
            return false
        }

        // Perform Luhn algorithm check
        return luhnCheck(cleanIMEI)
    }

    /**
     * Performs the Luhn algorithm check on the given number.
     */
    private fun luhnCheck(number: String): Boolean {
        var sum = 0
        var alternate = false
        for (i in number.length - 1 downTo 0) {
            var n = number[i] - '0'
            if (alternate) {
                n *= 2
                if (n > 9) {
                    n = (n % 10) + 1
                }
            }
            sum += n
            alternate = !alternate
        }
        return (sum % 10 == 0)
    }
}

================
File: NewDeviceCreator.kt
================
package com.trex.rexandroidsecureclient.utils

import DeviceDetailsUtil
import android.app.admin.DevicePolicyManager
import android.content.Context
import android.content.Intent
import android.util.Log
import android.widget.Toast
import com.trex.rexandroidsecureclient.MyApplication
import com.trex.rexnetwork.RetrofitClient
import com.trex.rexnetwork.data.NewDevice
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import retrofit2.Response

class NewDeviceCreator {
    private val TAG: String = "New Device Creator"
    private val context = MyApplication.getAppContext()
    private val clientSharedPrefs by lazy {
        ClientSharedPrefs()
    }
    private val deviceInfoUtils by lazy {
        DeviceDetailsUtil()
    }

    fun getImei(): String {
        deviceInfoUtils.saveImei()
        val imei = clientSharedPrefs.getImei()
        return imei;
    }

    fun isImeiAvailable(): Boolean {
        val imei = getImei()
        if (imei.isEmpty()) return false
        if (imei.isBlank()) return false
        if (imei == ClientSharedPrefs.IMEI_NOT_FOUND) return false
        return true
    }

    fun saveDevice(
        context: Context,
        intent: Intent,
        onSaved: () -> Unit,
    ) {
        // get device info

        // get shop id from intent
        val shopId = getShopIdFromIntent(intent)

        // create new device
        val newDevice = createNewDevice(context, shopId)

        if (newDevice.imeiOne == ClientSharedPrefs.IMEI_NOT_FOUND || newDevice.shopId == ClientSharedPrefs.DUMMY_SHOP_ID) {
            Toast.makeText(context, "Please Enter Details", Toast.LENGTH_SHORT).show()
            startMainActivity(context, newDevice)
        } else {
            saveDeviceToFirebase(newDevice) {
                onSaved()
            }
        }
    }

    fun createDummyDevice() {
        // get device info
        deviceInfoUtils.saveImei()

        // get shop id from intent
        val shopId = "+919910000163"

        // create new device
        val newDevice = createNewDevice(context, shopId)
        saveDeviceToFirebase(newDevice) {

        }
    }

    private fun getShopIdFromIntent(intent: Intent): String {
        val extras =
            intent.getBundleExtra(DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE)
        if (extras == null) {
            Log.e(TAG, "saveAndGetShopID: Extras null")
            Toast
                .makeText(
                    context,
                    ClientSharedPrefs.SHOP_ID_NOT_FOUND + " EMPTY BUNDLE!",
                    Toast.LENGTH_SHORT,
                ).show()
            return ClientSharedPrefs.DUMMY_SHOP_ID
        }
        val shopId = extras.getString(ClientSharedPrefs.SHOP_ID)
        if (shopId == null) {
            Toast
                .makeText(
                    context,
                    "${ClientSharedPrefs.SHOP_ID_NOT_FOUND} Shopid is null in extras",
                    Toast.LENGTH_SHORT,
                ).show()
            return ClientSharedPrefs.DUMMY_SHOP_ID
        }
        clientSharedPrefs.saveShopId(shopId)
        return shopId
    }

    private fun createNewDevice(
        context: Context,
        shopId: String,
    ): NewDevice {
        showNotificationOnDummyId(shopId, context)
        val device =
            NewDevice(
                shopId = shopId,
                imeiOne = clientSharedPrefs.getImei(),
                fcmToken = clientSharedPrefs.getFcmToken(),
                manufacturer = deviceInfoUtils.getManufacturer(),
                brand = deviceInfoUtils.getBrand(),
                modelNumber = deviceInfoUtils.getDeviceModel(),
                androidVersion = deviceInfoUtils.getAndroidVersion(),
                deviceCode = deviceInfoUtils.getDeviceId(),
            )

        return device
    }

    private fun showNotificationOnDummyId(
        shopId: String,
        context: Context,
    ) {
        if (shopId.equals(ClientSharedPrefs.DUMMY_SHOP_ID)) {
            Log.e(TAG, "createNewDevice: dumping device into dump shop!")
            Toast
                .makeText(
                    context,
                    "${ClientSharedPrefs.SHOP_ID_NOT_FOUND} SAVING INTO DUMMY SHOP",
                    Toast.LENGTH_SHORT,
                ).show()
        }
    }

    private fun startMainActivity(
        context: Context,
        newDevice: NewDevice,
    ) {
        //TODO
//        val launchIntent = Intent(context, MainActivity::class.java)
//        launchIntent.apply {
//            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
//            putExtra(MainActivity.NEW_DEVICE, newDevice)
//        }
//        context.startActivity(launchIntent)
    }

    fun saveDeviceToFirebase(
        newDevice: NewDevice,
        onResult: (Response<Unit>) -> Unit,
    ) {
        CoroutineScope(Dispatchers.IO).launch {
            val respose = RetrofitClient.builder.registerNewDevice(newDevice)
            onResult(respose)
        }
    }
}

================
File: PermissionHelper.kt
================
package com.trex.rexandroidsecureclient.utils

import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat

class PermissionHelper(
    private val context: Context,
) {
    companion object {
        private const val REQUEST_CODE = 123
    }

    fun checkAndRequestPermission(
        activity: Activity,
        permission: String,
        rationaleMsg: String,
        callback: (Boolean) -> Unit,
    ) {
        when {
            ContextCompat.checkSelfPermission(
                context,
                permission,
            ) == PackageManager.PERMISSION_GRANTED -> {
                callback(true)
            }

            else -> {
                ActivityCompat.requestPermissions(activity, arrayOf(permission), REQUEST_CODE)
            }
        }
    }
}

================
File: SharedPrefUtils.kt
================
package com.trex.rexandroidsecureclient.utils

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.trex.rexandroidsecureclient.MyApplication
import com.trex.rexandroidsecureclient.myclient.network.models.QrAdditionalData

open class SharedPrefUtil {
    private val context = MyApplication.getAppContext()
    val sharedPreferences: SharedPreferences =
        context.getSharedPreferences(ADDITIONAL_QRCODE_DATA, Context.MODE_PRIVATE)

    // Save JSON object to SharedPreferences
    fun <T> saveJson(
        key: String,
        data: T,
    ) {
        val jsonString = Gson().toJson(data)
        sharedPreferences.edit().putString(key, jsonString).apply()
    }

    // Retrieve JSON object from SharedPreferences
    inline fun <reified T> getJson(key: String): T? {
        val jsonString = sharedPreferences.getString(key, null)
        return if (jsonString != null) {
            Gson().fromJson(jsonString, object : TypeToken<T>() {}.type)
        } else {
            null
        }
    }

    // Remove a key
    fun remove(key: String) {
        sharedPreferences.edit().remove(key).apply()
    }

    fun getQrAdditionalData() = getJson<QrAdditionalData>(ADDITIONAL_QRCODE_DATA)

    fun saveQrAdditionalData(qrAdditionalData: QrAdditionalData) =
        saveJson(ADDITIONAL_QRCODE_DATA, qrAdditionalData)

    // Clear all stored data
    fun clear() {
        sharedPreferences.edit().clear().apply()
    }

    companion object {
        const val ADDITIONAL_QRCODE_DATA = "ADDITIONAL_QRCODE_DATA"
    }
}

class ClientSharedPrefs() : SharedPrefUtil() {
    companion object {
        const val IMEI = "IMEI"
        const val IMEI_NOT_FOUND = "IMEI_NOT_FOUND"
        const val FCM_TOKEN = "FCM_TOKEN"
        const val SHOP_ID = "SHOP_ID"
        const val SHOP_ID_NOT_FOUND = "SHOP_ID_NOT_FOUND"
        const val DUMMY_SHOP_ID = "DUMMY_SHOP_ID"
    }

    fun saveFcmToken(fcmToken: String) {
        saveJson(FCM_TOKEN, fcmToken)
    }

    fun saveImei(imei: String) {
        saveJson(IMEI, imei)
    }

    fun saveShopId(shopId: String) {
        saveJson(SHOP_ID, shopId)
    }

    fun getShopId(): String = getJson<String>(SHOP_ID) ?: DUMMY_SHOP_ID

    fun getImei(): String = getJson<String>(IMEI) ?: IMEI_NOT_FOUND

    fun getFcmToken() = getJson<String>(FCM_TOKEN) ?: "none"
}
